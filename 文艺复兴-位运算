# 文艺复兴-位运算

<a name="Esvpd"></a>
# JavaScript 位运算
JavaScript 将数字存储为 64 位浮点数，但所有按位运算都以 32 位二进制数执行。<br />在执行位运算之前，JavaScript 将数字转换为 32 位有符号整数。<br />执行按位操作后，结果将转换回 64 位 JavaScript 数。<br />在JavaScript里，数字都是基于IEEE 754标准的双精度64位的浮点数<br />一个数字的范围只能在`-(2^53 - 1)`至`2^53 - 1`之间
<a name="tlZev"></a>
## 位运算
按位操作符将其操作数当作32位的比特序列操作,返回值依然是标准的JavaScript数值

| 运算符 | 用法 | 描述 |
| --- | --- | --- |
| 按位与 | `a & b` | 对于每个比特位,只有两个操作数相应的比特位都是1时,结果才为1,否则为0 |
| 按位或 | `a | b` | 对于每个比特位,两个操作数相应的比特位至少有一个1时,结果为1,否则为0 |
| 按位异或 | `a ^ b` | 对于每个比特位,两个操作数相应的比特位有且只有一个1时,结果为1,否则为0 |
| 按位非 | `~a` | 反转操作数的比特位,即0变成1,1变成0 |
| 左移 | `a << b` | 将a的二进制形式向b(<32)比特位,右边用0填充 |
| 有符号右移 | `a >> b` | 将a的二进制表示向右移b(<32)位,丢弃被移除的位 |
| 无符号右移 | `a >>> b` | 将a的二进制表示向右移b位,丢弃被移出的位,并使用0在左侧填充 |

例子
```shell
# 与
      A = 10001001 137
      B = 10010000 136
A & B = 10000000 128
# 或
      A = 10001001 137
      B = 10001000 136
A & B = 10001001 137
# 异或
      A = 10001001 137
      B = 10001000 136
A & B = 00000001 1
# 非
      A = 10001001 137
    ~A = 01110110 118
# 左移
       A = 10001001 137
       B = 1
       C = 3
A << B = 000100010010 274 
A << C = 010001001000 1096
# 右移
       A = 10001001 137
       B = 1
       C = 3
A >> B = 000001000100 68 
A >> C = 000000010001 17

# 右移和无符号右移的区别
# 二进制表示最多32位,而最高位,也就是最左侧的一位,0和1分别代表正负号
# 普通右移时,最高位会根据数据本身的正负号补0或1
# 无符号右移不用顾虑这个,直接上0就行

# 无符号右移
                A = 1000000000000000000000010001001 -137
                B = 1
                C = 3
        A >> B = 0000000000000000000000001000100 536870894 
        A >> C = 0000000000000000000000000010001 2147483579
```
<a name="eXS4Q"></a>
# 实践应用
<a name="IkLnA"></a>
## 使用异或交换两个数
```javascript
let a = 5,
    b = 6;

a = a ^ b;
b = a ^ b; // b 等于 5
a = a ^ b; // a 等于 6
```
```javascript
let a = 5,
    b = 6;
// 交换a, b的值 
let c = a;
a = b;
b = c;
```
原理:

- 首先明确a ^ a = 0, b ^ b = 0; 
- 由a = a ^ b; b = a ^ b;
- 可以求出 b = (a ^ b) ^ b = a ^ (b ^ b) = a ^ 0 = a;
- 根据第三行,a = (a ^ b) ^ a = a ^ a ^ b = 0 ^ b = b;


<br />当然现在解构赋值在写法上可以更简洁的做到两数交换,但是了解一下异或的原理也挺有趣的
<a name="9rOuQ"></a>
## 使用~判断索引存在
```javascript
url += ~url.indexOf('?') ? '&' : '?'

url += url.indexOf('?') > -1 ? '&' '?'
```
原理: ~-1 = 0

- 1二进制的表示为0000...0001,第一位是符号位,0代表是正号
- 那么如果是-1的话,二进制的表示就是1000...0001,这是-1的原码
- 但是负数需要用补码来表示
   - 换算成反码: 符号位不动,其余位取反变成1111...1110
   - 反码再加1就变成了1111...1111,这就是-1的补码
- 所以-1的补码1111...1111按位取非就全部变成了0



<a name="Zm9NB"></a>
## 向下取整


```javascript
var data = 2.3;

var re2 = ~~data; // 2

var re2 = Math.floor(data); // 2
```
原理:

- 首先位运算对小数运算时,会自动转换为整数
- ~2.3 => ~2 = -3
- ~-3 = 2
- ~~2.3 = 2
<a name="9hs5X"></a>
## 权限校验


<a name="E4Frr"></a>
## 常见问题
<a name="Z1Awf"></a>
### 判断一个数是奇数还是偶数
```javascript
function getOdevity(n) {
	return n & 1 ? '奇数' : '偶数'
}
```
<a name="e81n3"></a>
### 判断一个数是否为2的n次方
```javascript
function isPowerOf2(n) {
	return n & n - 1 === 0
}
```


<a name="S1znL"></a>
# 总结
前端发展太快,各种框架,库都在飞速迭代,虽然给大家的日常业务开发带来了极大的便利,但是由于技术框架的多样性,东西太多太杂,最后大家都说学不动了.但是万变不离其宗,大家的差异都是表面的,同一个需求不同的写法,不管再怎么编译都会变成相同或类似的机器指令.所以说与其感叹学不动了,不如多去了解了解内部的本质.做到举一反三.<br />
<br />位运算就是很基础的东西,但是又很冷门,运算快不快的不说,平时业务中基本也不会碰到那种运算速度相差好几秒的场景.只是希望可以通过这个来引起大家对基础知识的兴趣,返璞归真.在以后的打怪升级中可以事半功倍.<br />

